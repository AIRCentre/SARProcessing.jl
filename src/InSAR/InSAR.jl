    # # fish out constants and parameters
    # c = 299792458
    # k_psi = meta["azimuth_steering_rate"] * pi/180
    # dc_coef = meta["burst_meta"]["data_dc_polynomial"][burst_number, :]
    # dc_tau0 = meta["burst_meta"]["data_dc_t0"][burst_number]
    # fm_coef = meta["burst_meta"]["azimuth_fm_rate_polynomial"][burst_number, :]
    # fm_tau0 = meta["burst_meta"]["azimuth_fm_rate_t0"][burst_number]
    # f_c = meta["radar_frequency"]
    # lines_per_burst = meta["lines_per_burst"]
    # number_of_samples = meta["number_of_samples"]
    # delta_t_s = meta["azimuth_time_interval"]
    # delta_tau_s = 1/meta["range_sampling_rate"]
    # tau_0 = meta["slant_range_time"]
    # v_s = v_mid

using SARProcessing
# TODO: CHANGE NAMING, THIS InSAR.jl should probably just have include() statements and another file or folder with some operations

SENTINEL1_SLC_METADATA_TEST_FILE = "test/testData/s1a-iw3-slc-vv-20220918t074921-20220918t074946-045056-056232-006.xml";
PRECISE_ORBIT_TEST_FILE = "test/testData/S1A_OPER_AUX_POEORB_20221119T081845.EOF";
orbit_states = SARProcessing.load_precise_orbit_sentinel1(PRECISE_ORBIT_TEST_FILE);
metadata = SARProcessing.Sentinel1MetaData(SENTINEL1_SLC_METADATA_TEST_FILE);

"""
phase_ramp(linesArray{Int,1}, samples::Array{Int,1}, burst_number::Int, meta::Dict, precise_orbit:Dict)

Computes the phase ramp (phi) for the given burst number for input lines and samples.

# NOTES
reference: Equation numbers refer to the document "Definition of the TOPS SLC deramping function 
for products generated by the S-1 IPF" by Miranda (2014): 
    https://sentinel.esa.int/documents/247904/1653442/sentinel-1-tops-slc_deramping
"""
function phase_ramp(lines, samples, burst_number, k_psi, dc_coefficient, 
                    dc_tau_0, fm_coefficient, fm_tau_0, f_c, lines_per_burst, 
                    number_of_samples, delta_t_s, delta_tau_s, tau_0, v_s, c)


    tau = tau_0 .+ (samples .- 1) .* delta_tau_s # Slant range time of ith sample, Eqn. 12

    # Doppler rate equations
    k_s = 2 * v_s/c * f_c * k_psi; # Doppler rate from antenna scanning, Eqn. 4
    alpha = 1 .- k_s ./ _doppler_fm_rate(tau, fm_coefficient, fm_tau_0); # conversion factor, Eqn. 3
    k_t = k_s ./ alpha; # Doppler Centroid Rate, Eqn. 2

    # Doppler azimuth time equations
    eta_c = - _doppler_centroid_frequency(tau, dc_coefficient, dc_tau_0) ./ _doppler_fm_rate(tau, fm_coefficient, fm_tau_0); # Beam centre crossing time, Eqn. 7
    tau_mid = tau_0 + number_of_samples/2 * delta_tau_s

    eta_ref = eta_c .- (- _doppler_centroid_frequency(tau_mid, dc_coefficient, dc_tau_0) / _doppler_fm_rate(tau_mid, fm_coefficient, fm_tau_0)); # Reference time, Eqn. 6
    line_in_burst = lines .- lines_per_burst * (burst_number - 1)
    eta = -lines_per_burst / 2 * delta_t_s .+ (line_in_burst .- 1/2 ) .* delta_t_s

    # Compute the phase ramp added the modulation term
    ramp = pi * k_t .* (eta .- eta_ref).^2 .+ 2 * pi .* _doppler_centroid_frequency(tau, dc_coefficient, dc_tau_0) .* (eta .- eta_ref); # Eqn. 14
    return ramp
end

"""
Computes Doppler FM rate (k_a), as given by equation 11 in the document "Definition of the TOPS SLC deramping function 
for products generated by the S-1 IPF" by Miranda (2014): https://sentinel.esa.int/documents/247904/1653442/sentinel-1-tops-slc_deramping
"""
_doppler_fm_rate(x, fm_param, x0) = fm_param[1] .+ fm_param[2].*(x .- x0) .+ fm_param[3].*(x .- x0).^2

"""
Computes Doppler centroid frequency (f_etac), as given by equation 13 in the document "Definition of the TOPS SLC deramping function 
for products generated by the S-1 IPF" by Miranda (2014): https://sentinel.esa.int/documents/247904/1653442/sentinel-1-tops-slc_deramping
"""
_doppler_centroid_frequency(x, dc_param, x0) = dc_param[1] .+ dc_param[2].*(x .- x0) .+ dc_param[3].*(x .- x0).^2;


function get_phase_ramp(lines, samples, burst_number, meta_data, orbit_states)
    k_psi = meta_data.product.azimuth_steering_rate * pi/180 ;
    dc_coefficient = meta_data.bursts[burst_number].doppler_centroid.polynomial;
    dc_tau_0 = meta_data.bursts[burst_number].doppler_centroid.t0;
    fm_coefficient = meta_data.bursts[burst_number].azimuth_fm_rate.polynomial;
    fm_tau_0 = meta_data.bursts[burst_number].azimuth_fm_rate.t0;
    f_c = meta_data.product.radar_frequency;
    lines_per_burst = meta_data.bursts[burst_number].lines_per_burst;
    number_of_samples = meta_data.image.number_of_samples;
    delta_t_s = meta_data.image.azimuth_time_interval;
    delta_tau_s = 1/meta_data.product.range_sampling_rate
    tau_0 = meta_data.image.slant_range_time.value
    c = 299792458;

    time_mid_burst = meta_data.bursts[burst_number].burst_mid_time;
    println(time_mid_burst)
    time_differences = [abs(orbit_states[i].time - time_mid_burst) for i in eachindex(orbit_states)];
    closest_time_index = argmin(time_differences);
    v_s = sqrt(sum(orbit_states[closest_time_index].velocity.^2));
    
    ramp = phase_ramp(lines, samples, burst_number, k_psi, dc_coefficient, 
                      dc_tau_0, fm_coefficient, fm_tau_0, f_c, lines_per_burst, 
                      number_of_samples, delta_t_s, delta_tau_s, tau_0, v_s, c);
    return ramp
end

# samples = 1037:2000;
# delta_tau_s = 1/metadata.product.range_sampling_rate
# tau_0 = metadata.image.slant_range_time.value

# fm_coefficient = metadata.bursts[1].azimuth_fm_rate.polynomial;
# fm_tau_0 = metadata.bursts[1].azimuth_fm_rate.t0;

# tau = tau_0 .+ (collect(samples) .- 1) .* delta_tau_s # Slant range time of ith sample, Eqn. 12

# _doppler_fm_rate(tau, fm_coefficient, fm_tau_0) 

# v = collect(1:1000);
# xgrid = repeat(v', length(v));
# ygrid = xgrid';
# ramp = get_phase_ramp(750:900, 1037:2000, 1, metadata, orbit_states);
# using Plots
# println(minimum(ramp))
# println(maximum(ramp))
# println(mean(ramp))